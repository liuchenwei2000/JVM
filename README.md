## Java虚拟机 ##

### Java内存模型 ###

Java 在内存分配时会涉及到以下区域：

* 寄存器：在程序中无法控制。
* 栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中。
* 堆：存放用new产生的数据。
* 静态域：存放在对象中用static定义的静态成员。
* 常量池：存放常量。
* 非RAM存储：硬盘等永久存储空间。

#### 栈

在方法定义中的一些基本类型的变量数据和对象的引用变量都在方法的栈内存中分配。当一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java 会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。

#### 堆

堆内存用来存放由 new 创建的对象和数组。在堆中分配的内存，由 JVM 的自动垃圾回收器来管理。在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起了一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。

引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能再被使用，但仍然占据着内存空间，在随后的一个不确定的时间被垃圾回收器收走释放掉内存。这也是 Java 比较占内存的原因。

#### 常量池（constant pool）

常量池指的是在编译期被确定，并被保存在已编译的 .class 文件中的一些数据。除了包含代码中所定义的各种基本类型（如int、double等）和对象型（如String及数组）的常量值（final）还包含一些以文本形式出现的符号引用，比如：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

虚拟机必须为每个被装载的类维护一个常量池。常量池就是该类所用到常量的一个有序集合，包括直接常量（Stirng、int等常量）和对其他类型，字段和方法的符号引用。对于 String 常量，它的值是在常量池中的。而 JVM 中的常量池在内存中是以表的形式存在的，该表只存储文字字符串值，不存储符号引用。


#### 堆和栈的比较

Java 的堆是一个运行时数据区，类的对象从中分配空间，它们不需要程序代码来显式的释放，堆是由垃圾回收来负责的。

* 堆的优势
	
	可以动态的分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的。垃圾回收器会自动回收这些不再使用的数据内存。

* 堆的缺点

	由于要在运行时动态分配内存，存取速度较慢。

* 栈的优势

	存取速度比堆要快，仅次于寄存器，栈数据可以共享。

* 栈的缺点

	存在栈中的数据大小和生存期必须是确定的，缺乏灵活性。

#### 栈的特殊性

存在栈中的数据可以共享。假设下面的代码：

	int a=3;
	int b=3;

编译器会先处理 `int a=3;` 首先它会在栈中创建一个名称为 a 的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将 a 指向3。

接着处理 `int b=3;` 在创建完b的引用变量后，因为在栈中已经有3这个值，便将 b 直接指向3。这样，就出现了 a 与 b 同时均指向3的情况。

这时，如果再令 `a=4；` 那么编译器会重复上述过程。但是a值的改变不会影响到 b 的值。

要注意这种数据的共享与两个引用同时指向一个对象的这种共享是不同的，因为这种情况 a 的修改不会影响到 b，它是由编译器完成的，它有利于节省空间。

而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。


### JVM参数 ###

虚拟机参数分为基本和扩展两类，在命令行中输入 `JAVA_HOME\bin\java` 就可得到基本参数列表，在命令行输入 `JAVA_HOME\bin\java –X` 就可得到扩展参数列表。

* -client，-server

	这两个参数用于设置虚拟机使用何种运行模式，client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。相反，server模式启动比client慢，但可获得更高的运行性能。

	在windows上，缺省的虚拟机类型为client模式，如果要使用server模式，就需要在启动虚拟机时加-server参数，以获得更高性能，对服务器端应用，推荐采用server模式，尤其是多个CPU的系统。在Linux，Solaris上缺省采用server模式。


* -hotspot

	含义与client相同，jdk1.4以前使用的参数，jdk1.4开始不再使用，代之以client。


* -classpath,-cp

	虚拟机在运行一个类时，需要将其装入内存，虚拟机搜索类的方式和顺序如下：

	Bootstrap classes，Extension classes，User classes。

	Bootstrap 中的路径是虚拟机自带的jar或zip文件，虚拟机首先搜索这些包文件，用System.getProperty("sun.boot.class.path")可得到虚拟机搜索的包名。


	Extension是位于jre\lib\ext目录下的jar文件，虚拟机在搜索完Bootstrap后就搜索该目录下的jar文件。用System.getProperty("java.ext.dirs")可得到虚拟机使用Extension搜索路径。

	User classes搜索顺序为当前目录、环境变量 CLASSPATH、-classpath。

	-classpath告知虚拟机搜索目录名、jar文档名、zip文档名，之间用分号;分隔。

	例如当你自己开发了公共类并包装成一个common.jar包，在使用common.jar中的类时，就需要用-classpath common.jar 告诉虚拟机从common.jar中查找该类，否则虚拟机就会抛出java.lang.NoClassDefFoundError异常，表明未找到类定义。

	在运行时可用System.getProperty("java.class.path")得到虚拟机查找类的路径。


	使用-classpath后虚拟机将不再使用CLASSPATH中的类搜索路径，如果-classpath和CLASSPATH都没有设置，则虚拟机使用当前路径(.)作为类搜索路径。


	推荐使用-classpath来定义虚拟机要搜索的类路径，而不要使用环境变量CLASSPATH的搜索路径，以减少多个项目同时使用CLASSPATH时存在的潜在冲突。例如应用1要使用a1.0.jar中的类G，应用2要使用a2.0.jar中的类G,a2.0.jar是a1.0.jar的升级包，当a1.0.jar，a2.0.jar都在CLASSPATH中，虚拟机搜索到第一个包中的类G时就停止搜索，如果应用1应用2的虚拟机都从CLASSPATH中搜索，就会有一个应用得不到正确版本的类G。


* -verbose[:class|gc|jni]

	在输出设备上显示虚拟机运行信息。

	verbose和verbose:class含义相同，输出虚拟机装入的类的信息，显示的信息格式如下：

	[Loaded java.io.FilePermission$1 from shared objects file]

	当虚拟机报告类找不到或类冲突时可用此参数来诊断来查看虚拟机从装入类的情况。

* -verbose:gc在虚拟机发生内存回收时在输出设备显示信息，格式如下：

	[Full GC 268K->168K(1984K), 0.0187390 secs]

	该参数用来监视虚拟机内存回收的情况。


* -verbose:jni在虚拟机调用native方法时输出设备显示信息，格式如下：

	[Dynamic-linking native method HelloNative.sum ... JNI]

	该参数用来监视虚拟机调用本地方法的情况，在发生jni错误时可为诊断提供便利。

* -version

	显示可运行的虚拟机版本信息然后退出。一台机器上装有不同版本的JDK时

* -showversion

	显示版本信息以及帮助信息。

* -Xmixed

	设置-client模式虚拟机对使用频率高的方式进行Just-In-Time编译和执行，对其他方法使用解释方式执行。该方式是虚拟机缺省模式。

* -Xint

	设置-client模式下运行的虚拟机以解释方式执行类的字节码，不将字节码编译为本机码。


* -Xbootclasspath:path

	-Xbootclasspath/a:path

	-Xbootclasspath/p:path

	改变虚拟机装载缺省系统运行包rt.jar而从-Xbootclasspath中设定的搜索路径中装载系统运行类。除非你自己能写一个运行时，否则不会用到该参数。

	/a:将在缺省搜索路径后加上path 中的搜索路径。

	/p:在缺省搜索路径前先搜索path中的搜索路径。


* -Xnoclassgc

	关闭虚拟机对class的垃圾回收功能。


* -Xincgc

	启动增量垃圾收集器，缺省是关闭的。增量垃圾收集器能减少偶然发生的长时间的垃圾回收造成的暂停时间。但增量垃圾收集器和应用程序并发执行，因此会占用部分CPU在应用程序上的功能。

* -Xloggc:<file>

	将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。

* -Xms<size>

	设置虚拟机可用内存堆的初始大小，缺省单位为字节，该大小为1024的整数倍并且要大于1MB，可用k(K)或m(M)为单位来设置较大的内存数。初始堆大小为2MB。

	例如：-Xms6400K，-Xms256M

* -Xmx<size>

	设置虚拟机内存堆的最大可用大小，缺省单位为字节。该值必须为1024整数倍，并且要大于2MB。可用k(K)或m(M)为单位来设置较大的内存数。缺省堆最大值为64MB。

	例如：-Xmx81920K，-Xmx80M

	当应用程序申请了大内存运行时虚拟机抛出java.lang.OutOfMemoryError: Java heap space错误，就需要使用-Xmx设置较大的可用内存堆。

* -Xss<size>

	设置线程栈的大小，缺省单位为字节。与-Xmx类似，也可用K或M来设置较大的值。通常操作系统分配给线程栈的缺省大小为1MB。

* -Xprof

	输出CPU运行时的诊断信息。

* -Xfuture

	对类文件进行严格格式检查，以保证类代码符合类代码规范。为保持向后兼容，虚拟机缺省不进行严格的格式检查。


