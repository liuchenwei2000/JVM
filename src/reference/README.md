## 对象的引用强度 ##

无论是通过计数算法判断对象的引用数量，还是通过跟搜索算法判断对象引用链是否可达，判断对象是否存活都与引用相关。

这里所说的引用是一般意义上申明的对象类型的变量（如String、Object等），区别于原始数据类型的变量（如int、long）。这种引用也称为强引用。

引用主要分为四种：强引用（strong reference）、软引用（soft reference）、弱引用（weak reference）、虚引用（phantom reference）。引用强度依次递减。

### 强引用

`String tag = new String();`

这里的 tag 引用就称之为强引用。强引用具有以下特征：

* 1，可以直接访问目标对象。
* 2，所指向的对象在任何时候都不会被系统回收。
* 3，可能导致内存泄漏。


下面的三种引用类型较之强引用而言都属于“弱引用”，也就是它们所引用的对象只要没有强引用，就会根据条件被 JVM 的垃圾回收器回收，只是回收的时机以及用法各不相同。

### SoftReference

SoftReference（软引用）用来描述一些还有用，但并非必须存在的对象。它所指向的对象，当没有强引用指向它时，会在内存中停留一段的时间，垃圾回收器会根据JVM内存的使用情况（内存的紧缺程度以及 `SoftReference.get()` 方法的调用情况来决定是否对其进行回收。如果释放完这些对象之后，内存还不足，才会抛出 OutOfMemoryError。

软引用具有以下特征：

* 1，使用 `get()` 方法取得对象的强引用从而访问目标对象。
* 2，所指向的对象按照 JVM 的使用情况（Heap 内存是否临近阀值）来决定是否回收。
* 3，可以避免 Heap 内存不足所导致的异常。

当垃圾回收器决定对其回收时，会先清空它的 SoftReference，也就是说 SoftReference 的 `get()` 方法将会返回 null，然后再调用对象的 `finalize()` 方法，并在下一轮 GC 中对其真正进行回收。

SoftReference 很适合用于实现缓存。

### WeakReference

WeakReference（弱引用）的特性和基本用法与软引用相似，区别就在于弱引用所指向的对象只要进行垃圾回收，不管内存使用情况如何，都会对其进行回收（`get()` 方法返回 null）。

弱引用具有以下特征：

* 1，使用 `get()` 方法取得对象的强引用从而访问目标对象。
* 2，一旦系统内存回收，无论内存是否紧张，弱引用所指向的对象都会被回收。
* 3，可以避免 Heap 内存不足所导致的异常。

弱引用最常见的用处是在集合类中，尤其是在哈希表中。哈希表的接口允许使用任何 Java 对象作为键来使用，当一个键值对被放入哈希表中之后，哈希表对象本身就有了对这些键和值对象的引用。如果这种引用是强引用的话，那么只要哈希表对象本身还存活，其中所包含的所有键值对对象都不会被回收。如果某个存活时间很长的哈希表中包含的键值对太多，最终就有可能耗尽JVM内存。对这种情况的解决办法是使用弱引用来引用这些对象，这样哈希表中的键值对象都能被垃圾回收，Java 提供了 WeakHashMap 来满足这一需求，它的键实际上是弱引用。

### PhantomReference

PhantomReference（虚引用）不同于软引用和弱引用，它无法通过 `get()` 方法来取得目标对象的强引用从而使用目标对象。它主要被用来跟踪对象被垃圾回收的状态，通过查看引用队列中是否包含对象所对应的虚引用来判断它是否即将被垃圾回收，从而采取行动。目标对象被回收前，它的引用会被放入一个 ReferenceQueue 对象中，从而达到跟踪对象垃圾回收的作用。

需要注意的是，对于引用回收方面，虚引用类似强引用不会自动根据内存情况自动对目标对象回收，客户端需要自己对其进行处理（比如调用 `System.gc()`）以防 Heap 内存不足异常。

虚引用具有以下特征：

* 1，永远无法使用 `get()` 方法取得对象的强引用从而访问目标对象。
* 2，虚引用所指向的对象在被系统回收前，虚引用自身会被放入 ReferenceQueue 对象中从而跟踪对象垃圾回收。
* 3，不会根据内存情况自动回收目标对象。

虚引用及其队列的使用情况并不多见，主要用来实现比较精细的内存使用控制，这对于移动设备来说是很有意义的。程序可以在确定一个对象要被回收之后，再申请内存创建新的对象。通过这种方式可以使得程序所消耗的内存维持在一个相对较低的数量。

<br/>

其实 SoftReference、WeakReference 以及 PhantomReference 的构造方法都可以接收一个 ReferenceQueue 对象。当 SoftReference、WeakReference 被清空的同时，也就是 GC 准备对它们所指向的对象进行回收时，调用对象的 `finalize()` 方法之前，它们自身会被加入到这个 ReferenceQueue 对象中，此时可以通过 ReferenceQueue 的 `poll()` 方法取到它们。而 PhantomReference 只有当 GC 对其所指向的对象真正进行回收时，才会将其加入到这个 ReferenceQueu e对象中。

需要注意的是，如果想使用这些相对强引用来说较弱的引用来进行对象操作的时候，就必须保证没有强引用指向被操作对象。否则对象将会被视为强引用指向，不会具有任何弱引用的特性。

当 GC 运行时，先扫描引用关系，GC 会对这三种类型的引用进行不同的处理。GC 首先会判断所扫描到的引用是否是 Reference 类型，如果是且其引用的对象无强引用，则认为该对象为相应的 Reference 类型，之后 GC 在垃圾回收时会根据 Reference 类型的不同采取不同的回收策略。
